#!/usr/bin/env node

/**
 * Build-time script to update contributors cache
 * This script fetches latest contributors from GitHub API and updates markdown cache files
 */

import { writeFileSync, readFileSync } from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Configuration
const CACHE_DIR = join(__dirname, "../src/content/prize");
const API_BASE = "https://api.github.com";
const REPOS_CONFIG = {
  mofa: {
    repos: ["mofa-org/mofa", "mofa-org/mofa-new"],
    cacheFile: "mofa-contributors.md",
    title: "MoFA Contributors",
    title_zh: "MoFA è´¡çŒ®è€…",
  },
  dora: {
    repos: ["dora-rs/dora"],
    cacheFile: "dora-contributors.md",
    title: "Dora-rs Contributors",
    title_zh: "Dora-rs è´¡çŒ®è€…",
  },
};

/**
 * Fetch all contributors with pagination
 */
async function fetchAllContributors(repo) {
  let allContributors = [];
  let page = 1;
  const perPage = 100;

  console.log(`Fetching contributors for ${repo}...`);

  try {
    while (true) {
      const url = `${API_BASE}/repos/${repo}/contributors?per_page=${perPage}&page=${page}`;
      const headers = {};

      // Add GitHub token if available
      if (process.env.GITHUB_TOKEN) {
        headers["Authorization"] = `token ${process.env.GITHUB_TOKEN}`;
      }

      const response = await fetch(url, { headers });

      if (!response.ok) {
        console.warn(
          `Failed to fetch ${repo} contributors page ${page}: ${response.status}`,
        );
        break;
      }

      const data = await response.json();

      if (data.length === 0) {
        break;
      }

      // Filter out bots
      const users = data.filter((contributor) => contributor.type === "User");
      allContributors = allContributors.concat(users);

      if (data.length < perPage) {
        break;
      }

      page++;

      // Add delay to respect rate limits
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  } catch (error) {
    console.error(`Error fetching ${repo} contributors:`, error.message);
  }

  console.log(`Fetched ${allContributors.length} contributors for ${repo}`);
  return allContributors;
}

/**
 * Merge contributors from multiple repositories
 */
function mergeContributors(contributorsLists, repos) {
  const merged = new Map();

  contributorsLists.forEach((contributors, index) => {
    const repo = repos[index];

    contributors.forEach((contributor) => {
      if (merged.has(contributor.login)) {
        // Merge contributions and add to repositories list
        const existing = merged.get(contributor.login);
        existing.contributions += contributor.contributions;
        existing.repositories.push(repo);
      } else {
        // New contributor
        merged.set(contributor.login, {
          name: contributor.login,
          contributions: contributor.contributions,
          avatar: contributor.avatar_url,
          github: contributor.html_url,
          repositories: [repo],
        });
      }
    });
  });

  return Array.from(merged.values());
}

/**
 * Generate markdown content for contributors cache
 */
function generateMarkdownContent(config, contributors) {
  const currentDate = new Date().toISOString().split("T")[0];

  const frontmatter = `---
type: "contributors"
category: "${config === REPOS_CONFIG.mofa ? "mofa" : "dora"}"
title: "${config.title}"
title_zh: "${config.title_zh}"
last_updated: "${currentDate}"
repositories: ${JSON.stringify(config.repos)}
total_contributors: ${contributors.length}
---`;

  const content = `
# ${config.title} Cache

è¿™ä¸ªæ–‡ä»¶åœ¨æ„å»ºæ—¶è‡ªåŠ¨æ›´æ–°ï¼Œç¼“å­˜ä»GitHub APIè·å–çš„è´¡çŒ®è€…æ•°æ®ã€‚

**æœ€åæ›´æ–°**: ${currentDate}
**æ€»è´¡çŒ®è€…æ•°**: ${contributors.length}
**æ•°æ®æ¥æº**: ${config.repos.join(", ")}

## Contributors Data

${contributors
  .map(
    (contributor) => `
### ${contributor.name}
- **Contributions**: ${contributor.contributions}
- **Avatar**: ${contributor.avatar}
- **GitHub**: ${contributor.github}
- **Repositories**: ${contributor.repositories.join(", ")}
`,
  )
  .join("")}

---
*This file is automatically generated during build time. Do not edit manually.*`;

  return frontmatter + content;
}

/**
 * Update contributors cache for a specific configuration
 */
async function updateContributorsCache(configKey) {
  const config = REPOS_CONFIG[configKey];
  console.log(`\\nğŸ“ Updating ${config.title} cache...`);

  // Fetch contributors from all repositories
  const contributorsLists = await Promise.all(
    config.repos.map((repo) => fetchAllContributors(repo)),
  );

  // Merge contributors from multiple repos
  const mergedContributors = mergeContributors(contributorsLists, config.repos);

  // Generate markdown content
  const markdownContent = generateMarkdownContent(config, mergedContributors);

  // Write to cache file
  const cacheFilePath = join(CACHE_DIR, config.cacheFile);
  try {
    writeFileSync(cacheFilePath, markdownContent, "utf8");
    console.log(
      `âœ… Updated ${config.cacheFile} with ${mergedContributors.length} contributors`,
    );
  } catch (error) {
    console.error(`âŒ Failed to write ${config.cacheFile}:`, error.message);
  }
}

/**
 * Fetch repository stats (stars, forks, etc.)
 */
async function fetchRepoStats(repo) {
  console.log(`Fetching repository stats for ${repo}...`);

  try {
    const url = `${API_BASE}/repos/${repo}`;
    const headers = {};

    // Add GitHub token if available
    if (process.env.GITHUB_TOKEN) {
      headers["Authorization"] = `token ${process.env.GITHUB_TOKEN}`;
    }

    const response = await fetch(url, { headers });

    if (!response.ok) {
      console.warn(
        `Failed to fetch ${repo} stats: ${response.status}`,
      );
      return null;
    }

    const data = await response.json();

    return {
      stars: data.stargazers_count,
      forks: data.forks_count,
      watchers: data.watchers_count,
      openIssues: data.open_issues_count,
    };
  } catch (error) {
    console.error(`Error fetching ${repo} stats:`, error.message);
    return null;
  }
}

/**
 * Generate markdown content for GitHub stats cache
 */
function generateStatsMarkdownContent(repo, stats) {
  const currentDate = new Date().toISOString().split("T")[0];

  const frontmatter = `---
type: "repo_stats"
category: "mofa"
title: "GitHub Repository Stats"
title_zh: "GitHub ä»“åº“ç»Ÿè®¡"
last_updated: "${currentDate}"
repository: "${repo}"
stars: ${stats.stars}
forks: ${stats.forks}
watchers: ${stats.watchers}
open_issues: ${stats.openIssues}
---`;

  const content = `
# GitHub Repository Stats Cache

è¿™ä¸ªæ–‡ä»¶åœ¨æ„å»ºæ—¶è‡ªåŠ¨æ›´æ–°ï¼Œç¼“å­˜ä» GitHub API è·å–çš„ä»“åº“ç»Ÿè®¡æ•°æ®ã€‚

**æœ€åæ›´æ–°**: ${currentDate}
**ä»“åº“**: ${repo}
**Stars**: ${stats.stars}
**Forks**: ${stats.forks}
**Watchers**: ${stats.watchers}
**Open Issues**: ${stats.openIssues}

---
*This file is automatically generated during build time. Do not edit manually.*`;

  return frontmatter + content;
}

/**
 * Update GitHub stats cache
 */
async function updateGitHubStatsCache() {
  console.log(`\\nâ­ Updating GitHub repository stats cache...`);

  const repo = "mofa-org/mofa";
  const stats = await fetchRepoStats(repo);

  if (!stats) {
    console.warn(`âš ï¸  Failed to fetch stats for ${repo}, skipping update`);
    return;
  }

  // Generate markdown content
  const markdownContent = generateStatsMarkdownContent(repo, stats);

  // Write to cache file
  const cacheFilePath = join(CACHE_DIR, "github-stats.md");
  try {
    writeFileSync(cacheFilePath, markdownContent, "utf8");
    console.log(
      `âœ… Updated github-stats.md with ${stats.stars} stars, ${stats.forks} forks`,
    );
  } catch (error) {
    console.error(`âŒ Failed to write github-stats.md:`, error.message);
  }
}

/**
 * Main function
 */
async function main() {
  console.log("ğŸš€ Starting cache update...");

  // Check if we're in CI or have GitHub token for higher rate limits
  if (process.env.GITHUB_TOKEN) {
    console.log("ğŸ”‘ GitHub token detected, using authenticated requests");
  } else {
    console.log(
      "âš ï¸  No GitHub token found, using unauthenticated requests (lower rate limit)",
    );
  }

  try {
    // Update all contributor caches
    await updateContributorsCache("mofa");
    await updateContributorsCache("dora");

    // Update GitHub stats cache
    await updateGitHubStatsCache();

    console.log("\\nâœ… All caches updated successfully!");
  } catch (error) {
    console.error("âŒ Failed to update cache:", error);
    process.exit(1);
  }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}
