#!/usr/bin/env node

/**
 * Build-time script to update contributors cache
 * This script fetches latest contributors from GitHub API and updates markdown cache files
 */

import { writeFileSync, readFileSync } from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Configuration
const CACHE_DIR = join(__dirname, "../src/content/prize");
const API_BASE = "https://api.github.com";
const REPOS_CONFIG = {
  mofa: {
    repos: ["mofa-org/mofa", "mofa-org/mofa-new"],
    cacheFile: "mofa-contributors.md",
    title: "MoFA Contributors",
    title_zh: "MoFA Ë¥°ÁåÆËÄÖ",
  },
  dora: {
    repos: ["dora-rs/dora"],
    cacheFile: "dora-contributors.md",
    title: "Dora-rs Contributors",
    title_zh: "Dora-rs Ë¥°ÁåÆËÄÖ",
  },
};

/**
 * Fetch all contributors with pagination
 */
async function fetchAllContributors(repo) {
  let allContributors = [];
  let page = 1;
  const perPage = 100;

  console.log(`Fetching contributors for ${repo}...`);

  try {
    while (true) {
      const url = `${API_BASE}/repos/${repo}/contributors?per_page=${perPage}&page=${page}`;
      const headers = {};

      // Add GitHub token if available
      if (process.env.GITHUB_TOKEN) {
        headers["Authorization"] = `token ${process.env.GITHUB_TOKEN}`;
      }

      const response = await fetch(url, { headers });

      if (!response.ok) {
        console.warn(
          `Failed to fetch ${repo} contributors page ${page}: ${response.status}`,
        );
        break;
      }

      const data = await response.json();

      if (data.length === 0) {
        break;
      }

      // Filter out bots
      const users = data.filter((contributor) => contributor.type === "User");
      allContributors = allContributors.concat(users);

      if (data.length < perPage) {
        break;
      }

      page++;

      // Add delay to respect rate limits
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  } catch (error) {
    console.error(`Error fetching ${repo} contributors:`, error.message);
  }

  console.log(`Fetched ${allContributors.length} contributors for ${repo}`);
  return allContributors;
}

/**
 * Merge contributors from multiple repositories
 */
function mergeContributors(contributorsLists, repos) {
  const merged = new Map();

  contributorsLists.forEach((contributors, index) => {
    const repo = repos[index];

    contributors.forEach((contributor) => {
      if (merged.has(contributor.login)) {
        // Merge contributions and add to repositories list
        const existing = merged.get(contributor.login);
        existing.contributions += contributor.contributions;
        existing.repositories.push(repo);
      } else {
        // New contributor
        merged.set(contributor.login, {
          name: contributor.login,
          contributions: contributor.contributions,
          avatar: contributor.avatar_url,
          github: contributor.html_url,
          repositories: [repo],
        });
      }
    });
  });

  return Array.from(merged.values());
}

/**
 * Generate markdown content for contributors cache
 */
function generateMarkdownContent(config, contributors) {
  const currentDate = new Date().toISOString().split("T")[0];

  const frontmatter = `---
type: "contributors"
category: "${config === REPOS_CONFIG.mofa ? "mofa" : "dora"}"
title: "${config.title}"
title_zh: "${config.title_zh}"
last_updated: "${currentDate}"
repositories: ${JSON.stringify(config.repos)}
total_contributors: ${contributors.length}
---`;

  const content = `
# ${config.title} Cache

Ëøô‰∏™Êñá‰ª∂Âú®ÊûÑÂª∫Êó∂Ëá™Âä®Êõ¥Êñ∞ÔºåÁºìÂ≠ò‰ªéGitHub APIËé∑ÂèñÁöÑË¥°ÁåÆËÄÖÊï∞ÊçÆ„ÄÇ

**ÊúÄÂêéÊõ¥Êñ∞**: ${currentDate}
**ÊÄªË¥°ÁåÆËÄÖÊï∞**: ${contributors.length}
**Êï∞ÊçÆÊù•Ê∫ê**: ${config.repos.join(", ")}

## Contributors Data

${contributors
  .map(
    (contributor) => `
### ${contributor.name}
- **Contributions**: ${contributor.contributions}
- **Avatar**: ${contributor.avatar}
- **GitHub**: ${contributor.github}
- **Repositories**: ${contributor.repositories.join(", ")}
`,
  )
  .join("")}

---
*This file is automatically generated during build time. Do not edit manually.*`;

  return frontmatter + content;
}

/**
 * Update contributors cache for a specific configuration
 */
async function updateContributorsCache(configKey) {
  const config = REPOS_CONFIG[configKey];
  console.log(`\\nüìù Updating ${config.title} cache...`);

  // Fetch contributors from all repositories
  const contributorsLists = await Promise.all(
    config.repos.map((repo) => fetchAllContributors(repo)),
  );

  // Merge contributors from multiple repos
  const mergedContributors = mergeContributors(contributorsLists, config.repos);

  // Generate markdown content
  const markdownContent = generateMarkdownContent(config, mergedContributors);

  // Write to cache file
  const cacheFilePath = join(CACHE_DIR, config.cacheFile);
  try {
    writeFileSync(cacheFilePath, markdownContent, "utf8");
    console.log(
      `‚úÖ Updated ${config.cacheFile} with ${mergedContributors.length} contributors`,
    );
  } catch (error) {
    console.error(`‚ùå Failed to write ${config.cacheFile}:`, error.message);
  }
}

/**
 * Main function
 */
async function main() {
  console.log("üöÄ Starting contributors cache update...");

  // Check if we're in CI or have GitHub token for higher rate limits
  if (process.env.GITHUB_TOKEN) {
    console.log("üîë GitHub token detected, using authenticated requests");
  } else {
    console.log(
      "‚ö†Ô∏è  No GitHub token found, using unauthenticated requests (lower rate limit)",
    );
  }

  try {
    // Update all contributor caches
    await updateContributorsCache("mofa");
    await updateContributorsCache("dora");

    console.log("\\n‚úÖ All contributors caches updated successfully!");
  } catch (error) {
    console.error("‚ùå Failed to update contributors cache:", error);
    process.exit(1);
  }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}
